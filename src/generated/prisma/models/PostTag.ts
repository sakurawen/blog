
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `PostTag` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model PostTag
 * 
 */
export type PostTagModel = runtime.Types.Result.DefaultSelection<Prisma.$PostTagPayload>

export type AggregatePostTag = {
  _count: PostTagCountAggregateOutputType | null
  _min: PostTagMinAggregateOutputType | null
  _max: PostTagMaxAggregateOutputType | null
}

export type PostTagMinAggregateOutputType = {
  postId: string | null
  tagId: string | null
}

export type PostTagMaxAggregateOutputType = {
  postId: string | null
  tagId: string | null
}

export type PostTagCountAggregateOutputType = {
  postId: number
  tagId: number
  _all: number
}


export type PostTagMinAggregateInputType = {
  postId?: true
  tagId?: true
}

export type PostTagMaxAggregateInputType = {
  postId?: true
  tagId?: true
}

export type PostTagCountAggregateInputType = {
  postId?: true
  tagId?: true
  _all?: true
}

export type PostTagAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which PostTag to aggregate.
   */
  where?: Prisma.PostTagWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PostTags to fetch.
   */
  orderBy?: Prisma.PostTagOrderByWithRelationInput | Prisma.PostTagOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.PostTagWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PostTags from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PostTags.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned PostTags
  **/
  _count?: true | PostTagCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: PostTagMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: PostTagMaxAggregateInputType
}

export type GetPostTagAggregateType<T extends PostTagAggregateArgs> = {
      [P in keyof T & keyof AggregatePostTag]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregatePostTag[P]>
    : Prisma.GetScalarType<T[P], AggregatePostTag[P]>
}




export type PostTagGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.PostTagWhereInput
  orderBy?: Prisma.PostTagOrderByWithAggregationInput | Prisma.PostTagOrderByWithAggregationInput[]
  by: Prisma.PostTagScalarFieldEnum[] | Prisma.PostTagScalarFieldEnum
  having?: Prisma.PostTagScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: PostTagCountAggregateInputType | true
  _min?: PostTagMinAggregateInputType
  _max?: PostTagMaxAggregateInputType
}

export type PostTagGroupByOutputType = {
  postId: string
  tagId: string
  _count: PostTagCountAggregateOutputType | null
  _min: PostTagMinAggregateOutputType | null
  _max: PostTagMaxAggregateOutputType | null
}

type GetPostTagGroupByPayload<T extends PostTagGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<PostTagGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof PostTagGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], PostTagGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], PostTagGroupByOutputType[P]>
      }
    >
  >



export type PostTagWhereInput = {
  AND?: Prisma.PostTagWhereInput | Prisma.PostTagWhereInput[]
  OR?: Prisma.PostTagWhereInput[]
  NOT?: Prisma.PostTagWhereInput | Prisma.PostTagWhereInput[]
  postId?: Prisma.StringFilter<"PostTag"> | string
  tagId?: Prisma.StringFilter<"PostTag"> | string
  post?: Prisma.XOR<Prisma.PostScalarRelationFilter, Prisma.PostWhereInput>
  tag?: Prisma.XOR<Prisma.TagScalarRelationFilter, Prisma.TagWhereInput>
}

export type PostTagOrderByWithRelationInput = {
  postId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
  post?: Prisma.PostOrderByWithRelationInput
  tag?: Prisma.TagOrderByWithRelationInput
}

export type PostTagWhereUniqueInput = Prisma.AtLeast<{
  postId_tagId?: Prisma.PostTagPostIdTagIdCompoundUniqueInput
  AND?: Prisma.PostTagWhereInput | Prisma.PostTagWhereInput[]
  OR?: Prisma.PostTagWhereInput[]
  NOT?: Prisma.PostTagWhereInput | Prisma.PostTagWhereInput[]
  postId?: Prisma.StringFilter<"PostTag"> | string
  tagId?: Prisma.StringFilter<"PostTag"> | string
  post?: Prisma.XOR<Prisma.PostScalarRelationFilter, Prisma.PostWhereInput>
  tag?: Prisma.XOR<Prisma.TagScalarRelationFilter, Prisma.TagWhereInput>
}, "postId_tagId">

export type PostTagOrderByWithAggregationInput = {
  postId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
  _count?: Prisma.PostTagCountOrderByAggregateInput
  _max?: Prisma.PostTagMaxOrderByAggregateInput
  _min?: Prisma.PostTagMinOrderByAggregateInput
}

export type PostTagScalarWhereWithAggregatesInput = {
  AND?: Prisma.PostTagScalarWhereWithAggregatesInput | Prisma.PostTagScalarWhereWithAggregatesInput[]
  OR?: Prisma.PostTagScalarWhereWithAggregatesInput[]
  NOT?: Prisma.PostTagScalarWhereWithAggregatesInput | Prisma.PostTagScalarWhereWithAggregatesInput[]
  postId?: Prisma.StringWithAggregatesFilter<"PostTag"> | string
  tagId?: Prisma.StringWithAggregatesFilter<"PostTag"> | string
}

export type PostTagCreateInput = {
  post: Prisma.PostCreateNestedOneWithoutPostTagsInput
  tag: Prisma.TagCreateNestedOneWithoutPostTagsInput
}

export type PostTagUncheckedCreateInput = {
  postId: string
  tagId: string
}

export type PostTagUpdateInput = {
  post?: Prisma.PostUpdateOneRequiredWithoutPostTagsNestedInput
  tag?: Prisma.TagUpdateOneRequiredWithoutPostTagsNestedInput
}

export type PostTagUncheckedUpdateInput = {
  postId?: Prisma.StringFieldUpdateOperationsInput | string
  tagId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type PostTagCreateManyInput = {
  postId: string
  tagId: string
}

export type PostTagUpdateManyMutationInput = {

}

export type PostTagUncheckedUpdateManyInput = {
  postId?: Prisma.StringFieldUpdateOperationsInput | string
  tagId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type PostTagListRelationFilter = {
  every?: Prisma.PostTagWhereInput
  some?: Prisma.PostTagWhereInput
  none?: Prisma.PostTagWhereInput
}

export type PostTagOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type PostTagPostIdTagIdCompoundUniqueInput = {
  postId: string
  tagId: string
}

export type PostTagCountOrderByAggregateInput = {
  postId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
}

export type PostTagMaxOrderByAggregateInput = {
  postId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
}

export type PostTagMinOrderByAggregateInput = {
  postId?: Prisma.SortOrder
  tagId?: Prisma.SortOrder
}

export type PostTagCreateNestedManyWithoutTagInput = {
  create?: Prisma.XOR<Prisma.PostTagCreateWithoutTagInput, Prisma.PostTagUncheckedCreateWithoutTagInput> | Prisma.PostTagCreateWithoutTagInput[] | Prisma.PostTagUncheckedCreateWithoutTagInput[]
  connectOrCreate?: Prisma.PostTagCreateOrConnectWithoutTagInput | Prisma.PostTagCreateOrConnectWithoutTagInput[]
  createMany?: Prisma.PostTagCreateManyTagInputEnvelope
  connect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
}

export type PostTagUncheckedCreateNestedManyWithoutTagInput = {
  create?: Prisma.XOR<Prisma.PostTagCreateWithoutTagInput, Prisma.PostTagUncheckedCreateWithoutTagInput> | Prisma.PostTagCreateWithoutTagInput[] | Prisma.PostTagUncheckedCreateWithoutTagInput[]
  connectOrCreate?: Prisma.PostTagCreateOrConnectWithoutTagInput | Prisma.PostTagCreateOrConnectWithoutTagInput[]
  createMany?: Prisma.PostTagCreateManyTagInputEnvelope
  connect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
}

export type PostTagUpdateManyWithoutTagNestedInput = {
  create?: Prisma.XOR<Prisma.PostTagCreateWithoutTagInput, Prisma.PostTagUncheckedCreateWithoutTagInput> | Prisma.PostTagCreateWithoutTagInput[] | Prisma.PostTagUncheckedCreateWithoutTagInput[]
  connectOrCreate?: Prisma.PostTagCreateOrConnectWithoutTagInput | Prisma.PostTagCreateOrConnectWithoutTagInput[]
  upsert?: Prisma.PostTagUpsertWithWhereUniqueWithoutTagInput | Prisma.PostTagUpsertWithWhereUniqueWithoutTagInput[]
  createMany?: Prisma.PostTagCreateManyTagInputEnvelope
  set?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  disconnect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  delete?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  connect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  update?: Prisma.PostTagUpdateWithWhereUniqueWithoutTagInput | Prisma.PostTagUpdateWithWhereUniqueWithoutTagInput[]
  updateMany?: Prisma.PostTagUpdateManyWithWhereWithoutTagInput | Prisma.PostTagUpdateManyWithWhereWithoutTagInput[]
  deleteMany?: Prisma.PostTagScalarWhereInput | Prisma.PostTagScalarWhereInput[]
}

export type PostTagUncheckedUpdateManyWithoutTagNestedInput = {
  create?: Prisma.XOR<Prisma.PostTagCreateWithoutTagInput, Prisma.PostTagUncheckedCreateWithoutTagInput> | Prisma.PostTagCreateWithoutTagInput[] | Prisma.PostTagUncheckedCreateWithoutTagInput[]
  connectOrCreate?: Prisma.PostTagCreateOrConnectWithoutTagInput | Prisma.PostTagCreateOrConnectWithoutTagInput[]
  upsert?: Prisma.PostTagUpsertWithWhereUniqueWithoutTagInput | Prisma.PostTagUpsertWithWhereUniqueWithoutTagInput[]
  createMany?: Prisma.PostTagCreateManyTagInputEnvelope
  set?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  disconnect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  delete?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  connect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  update?: Prisma.PostTagUpdateWithWhereUniqueWithoutTagInput | Prisma.PostTagUpdateWithWhereUniqueWithoutTagInput[]
  updateMany?: Prisma.PostTagUpdateManyWithWhereWithoutTagInput | Prisma.PostTagUpdateManyWithWhereWithoutTagInput[]
  deleteMany?: Prisma.PostTagScalarWhereInput | Prisma.PostTagScalarWhereInput[]
}

export type PostTagCreateNestedManyWithoutPostInput = {
  create?: Prisma.XOR<Prisma.PostTagCreateWithoutPostInput, Prisma.PostTagUncheckedCreateWithoutPostInput> | Prisma.PostTagCreateWithoutPostInput[] | Prisma.PostTagUncheckedCreateWithoutPostInput[]
  connectOrCreate?: Prisma.PostTagCreateOrConnectWithoutPostInput | Prisma.PostTagCreateOrConnectWithoutPostInput[]
  createMany?: Prisma.PostTagCreateManyPostInputEnvelope
  connect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
}

export type PostTagUncheckedCreateNestedManyWithoutPostInput = {
  create?: Prisma.XOR<Prisma.PostTagCreateWithoutPostInput, Prisma.PostTagUncheckedCreateWithoutPostInput> | Prisma.PostTagCreateWithoutPostInput[] | Prisma.PostTagUncheckedCreateWithoutPostInput[]
  connectOrCreate?: Prisma.PostTagCreateOrConnectWithoutPostInput | Prisma.PostTagCreateOrConnectWithoutPostInput[]
  createMany?: Prisma.PostTagCreateManyPostInputEnvelope
  connect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
}

export type PostTagUpdateManyWithoutPostNestedInput = {
  create?: Prisma.XOR<Prisma.PostTagCreateWithoutPostInput, Prisma.PostTagUncheckedCreateWithoutPostInput> | Prisma.PostTagCreateWithoutPostInput[] | Prisma.PostTagUncheckedCreateWithoutPostInput[]
  connectOrCreate?: Prisma.PostTagCreateOrConnectWithoutPostInput | Prisma.PostTagCreateOrConnectWithoutPostInput[]
  upsert?: Prisma.PostTagUpsertWithWhereUniqueWithoutPostInput | Prisma.PostTagUpsertWithWhereUniqueWithoutPostInput[]
  createMany?: Prisma.PostTagCreateManyPostInputEnvelope
  set?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  disconnect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  delete?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  connect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  update?: Prisma.PostTagUpdateWithWhereUniqueWithoutPostInput | Prisma.PostTagUpdateWithWhereUniqueWithoutPostInput[]
  updateMany?: Prisma.PostTagUpdateManyWithWhereWithoutPostInput | Prisma.PostTagUpdateManyWithWhereWithoutPostInput[]
  deleteMany?: Prisma.PostTagScalarWhereInput | Prisma.PostTagScalarWhereInput[]
}

export type PostTagUncheckedUpdateManyWithoutPostNestedInput = {
  create?: Prisma.XOR<Prisma.PostTagCreateWithoutPostInput, Prisma.PostTagUncheckedCreateWithoutPostInput> | Prisma.PostTagCreateWithoutPostInput[] | Prisma.PostTagUncheckedCreateWithoutPostInput[]
  connectOrCreate?: Prisma.PostTagCreateOrConnectWithoutPostInput | Prisma.PostTagCreateOrConnectWithoutPostInput[]
  upsert?: Prisma.PostTagUpsertWithWhereUniqueWithoutPostInput | Prisma.PostTagUpsertWithWhereUniqueWithoutPostInput[]
  createMany?: Prisma.PostTagCreateManyPostInputEnvelope
  set?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  disconnect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  delete?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  connect?: Prisma.PostTagWhereUniqueInput | Prisma.PostTagWhereUniqueInput[]
  update?: Prisma.PostTagUpdateWithWhereUniqueWithoutPostInput | Prisma.PostTagUpdateWithWhereUniqueWithoutPostInput[]
  updateMany?: Prisma.PostTagUpdateManyWithWhereWithoutPostInput | Prisma.PostTagUpdateManyWithWhereWithoutPostInput[]
  deleteMany?: Prisma.PostTagScalarWhereInput | Prisma.PostTagScalarWhereInput[]
}

export type PostTagCreateWithoutTagInput = {
  post: Prisma.PostCreateNestedOneWithoutPostTagsInput
}

export type PostTagUncheckedCreateWithoutTagInput = {
  postId: string
}

export type PostTagCreateOrConnectWithoutTagInput = {
  where: Prisma.PostTagWhereUniqueInput
  create: Prisma.XOR<Prisma.PostTagCreateWithoutTagInput, Prisma.PostTagUncheckedCreateWithoutTagInput>
}

export type PostTagCreateManyTagInputEnvelope = {
  data: Prisma.PostTagCreateManyTagInput | Prisma.PostTagCreateManyTagInput[]
  skipDuplicates?: boolean
}

export type PostTagUpsertWithWhereUniqueWithoutTagInput = {
  where: Prisma.PostTagWhereUniqueInput
  update: Prisma.XOR<Prisma.PostTagUpdateWithoutTagInput, Prisma.PostTagUncheckedUpdateWithoutTagInput>
  create: Prisma.XOR<Prisma.PostTagCreateWithoutTagInput, Prisma.PostTagUncheckedCreateWithoutTagInput>
}

export type PostTagUpdateWithWhereUniqueWithoutTagInput = {
  where: Prisma.PostTagWhereUniqueInput
  data: Prisma.XOR<Prisma.PostTagUpdateWithoutTagInput, Prisma.PostTagUncheckedUpdateWithoutTagInput>
}

export type PostTagUpdateManyWithWhereWithoutTagInput = {
  where: Prisma.PostTagScalarWhereInput
  data: Prisma.XOR<Prisma.PostTagUpdateManyMutationInput, Prisma.PostTagUncheckedUpdateManyWithoutTagInput>
}

export type PostTagScalarWhereInput = {
  AND?: Prisma.PostTagScalarWhereInput | Prisma.PostTagScalarWhereInput[]
  OR?: Prisma.PostTagScalarWhereInput[]
  NOT?: Prisma.PostTagScalarWhereInput | Prisma.PostTagScalarWhereInput[]
  postId?: Prisma.StringFilter<"PostTag"> | string
  tagId?: Prisma.StringFilter<"PostTag"> | string
}

export type PostTagCreateWithoutPostInput = {
  tag: Prisma.TagCreateNestedOneWithoutPostTagsInput
}

export type PostTagUncheckedCreateWithoutPostInput = {
  tagId: string
}

export type PostTagCreateOrConnectWithoutPostInput = {
  where: Prisma.PostTagWhereUniqueInput
  create: Prisma.XOR<Prisma.PostTagCreateWithoutPostInput, Prisma.PostTagUncheckedCreateWithoutPostInput>
}

export type PostTagCreateManyPostInputEnvelope = {
  data: Prisma.PostTagCreateManyPostInput | Prisma.PostTagCreateManyPostInput[]
  skipDuplicates?: boolean
}

export type PostTagUpsertWithWhereUniqueWithoutPostInput = {
  where: Prisma.PostTagWhereUniqueInput
  update: Prisma.XOR<Prisma.PostTagUpdateWithoutPostInput, Prisma.PostTagUncheckedUpdateWithoutPostInput>
  create: Prisma.XOR<Prisma.PostTagCreateWithoutPostInput, Prisma.PostTagUncheckedCreateWithoutPostInput>
}

export type PostTagUpdateWithWhereUniqueWithoutPostInput = {
  where: Prisma.PostTagWhereUniqueInput
  data: Prisma.XOR<Prisma.PostTagUpdateWithoutPostInput, Prisma.PostTagUncheckedUpdateWithoutPostInput>
}

export type PostTagUpdateManyWithWhereWithoutPostInput = {
  where: Prisma.PostTagScalarWhereInput
  data: Prisma.XOR<Prisma.PostTagUpdateManyMutationInput, Prisma.PostTagUncheckedUpdateManyWithoutPostInput>
}

export type PostTagCreateManyTagInput = {
  postId: string
}

export type PostTagUpdateWithoutTagInput = {
  post?: Prisma.PostUpdateOneRequiredWithoutPostTagsNestedInput
}

export type PostTagUncheckedUpdateWithoutTagInput = {
  postId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type PostTagUncheckedUpdateManyWithoutTagInput = {
  postId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type PostTagCreateManyPostInput = {
  tagId: string
}

export type PostTagUpdateWithoutPostInput = {
  tag?: Prisma.TagUpdateOneRequiredWithoutPostTagsNestedInput
}

export type PostTagUncheckedUpdateWithoutPostInput = {
  tagId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type PostTagUncheckedUpdateManyWithoutPostInput = {
  tagId?: Prisma.StringFieldUpdateOperationsInput | string
}



export type PostTagSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  postId?: boolean
  tagId?: boolean
  post?: boolean | Prisma.PostDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}, ExtArgs["result"]["postTag"]>

export type PostTagSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  postId?: boolean
  tagId?: boolean
  post?: boolean | Prisma.PostDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}, ExtArgs["result"]["postTag"]>

export type PostTagSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  postId?: boolean
  tagId?: boolean
  post?: boolean | Prisma.PostDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}, ExtArgs["result"]["postTag"]>

export type PostTagSelectScalar = {
  postId?: boolean
  tagId?: boolean
}

export type PostTagOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"postId" | "tagId", ExtArgs["result"]["postTag"]>
export type PostTagInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  post?: boolean | Prisma.PostDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}
export type PostTagIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  post?: boolean | Prisma.PostDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}
export type PostTagIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  post?: boolean | Prisma.PostDefaultArgs<ExtArgs>
  tag?: boolean | Prisma.TagDefaultArgs<ExtArgs>
}

export type $PostTagPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "PostTag"
  objects: {
    post: Prisma.$PostPayload<ExtArgs>
    tag: Prisma.$TagPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    postId: string
    tagId: string
  }, ExtArgs["result"]["postTag"]>
  composites: {}
}

export type PostTagGetPayload<S extends boolean | null | undefined | PostTagDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$PostTagPayload, S>

export type PostTagCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<PostTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PostTagCountAggregateInputType | true
  }

export interface PostTagDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostTag'], meta: { name: 'PostTag' } }
  /**
   * Find zero or one PostTag that matches the filter.
   * @param {PostTagFindUniqueArgs} args - Arguments to find a PostTag
   * @example
   * // Get one PostTag
   * const postTag = await prisma.postTag.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends PostTagFindUniqueArgs>(args: Prisma.SelectSubset<T, PostTagFindUniqueArgs<ExtArgs>>): Prisma.Prisma__PostTagClient<runtime.Types.Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one PostTag that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {PostTagFindUniqueOrThrowArgs} args - Arguments to find a PostTag
   * @example
   * // Get one PostTag
   * const postTag = await prisma.postTag.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends PostTagFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, PostTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__PostTagClient<runtime.Types.Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first PostTag that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PostTagFindFirstArgs} args - Arguments to find a PostTag
   * @example
   * // Get one PostTag
   * const postTag = await prisma.postTag.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends PostTagFindFirstArgs>(args?: Prisma.SelectSubset<T, PostTagFindFirstArgs<ExtArgs>>): Prisma.Prisma__PostTagClient<runtime.Types.Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first PostTag that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PostTagFindFirstOrThrowArgs} args - Arguments to find a PostTag
   * @example
   * // Get one PostTag
   * const postTag = await prisma.postTag.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends PostTagFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, PostTagFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__PostTagClient<runtime.Types.Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more PostTags that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PostTagFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all PostTags
   * const postTags = await prisma.postTag.findMany()
   * 
   * // Get first 10 PostTags
   * const postTags = await prisma.postTag.findMany({ take: 10 })
   * 
   * // Only select the `postId`
   * const postTagWithPostIdOnly = await prisma.postTag.findMany({ select: { postId: true } })
   * 
   */
  findMany<T extends PostTagFindManyArgs>(args?: Prisma.SelectSubset<T, PostTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a PostTag.
   * @param {PostTagCreateArgs} args - Arguments to create a PostTag.
   * @example
   * // Create one PostTag
   * const PostTag = await prisma.postTag.create({
   *   data: {
   *     // ... data to create a PostTag
   *   }
   * })
   * 
   */
  create<T extends PostTagCreateArgs>(args: Prisma.SelectSubset<T, PostTagCreateArgs<ExtArgs>>): Prisma.Prisma__PostTagClient<runtime.Types.Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many PostTags.
   * @param {PostTagCreateManyArgs} args - Arguments to create many PostTags.
   * @example
   * // Create many PostTags
   * const postTag = await prisma.postTag.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends PostTagCreateManyArgs>(args?: Prisma.SelectSubset<T, PostTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many PostTags and returns the data saved in the database.
   * @param {PostTagCreateManyAndReturnArgs} args - Arguments to create many PostTags.
   * @example
   * // Create many PostTags
   * const postTag = await prisma.postTag.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many PostTags and only return the `postId`
   * const postTagWithPostIdOnly = await prisma.postTag.createManyAndReturn({
   *   select: { postId: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends PostTagCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, PostTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a PostTag.
   * @param {PostTagDeleteArgs} args - Arguments to delete one PostTag.
   * @example
   * // Delete one PostTag
   * const PostTag = await prisma.postTag.delete({
   *   where: {
   *     // ... filter to delete one PostTag
   *   }
   * })
   * 
   */
  delete<T extends PostTagDeleteArgs>(args: Prisma.SelectSubset<T, PostTagDeleteArgs<ExtArgs>>): Prisma.Prisma__PostTagClient<runtime.Types.Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one PostTag.
   * @param {PostTagUpdateArgs} args - Arguments to update one PostTag.
   * @example
   * // Update one PostTag
   * const postTag = await prisma.postTag.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends PostTagUpdateArgs>(args: Prisma.SelectSubset<T, PostTagUpdateArgs<ExtArgs>>): Prisma.Prisma__PostTagClient<runtime.Types.Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more PostTags.
   * @param {PostTagDeleteManyArgs} args - Arguments to filter PostTags to delete.
   * @example
   * // Delete a few PostTags
   * const { count } = await prisma.postTag.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends PostTagDeleteManyArgs>(args?: Prisma.SelectSubset<T, PostTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more PostTags.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PostTagUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many PostTags
   * const postTag = await prisma.postTag.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends PostTagUpdateManyArgs>(args: Prisma.SelectSubset<T, PostTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more PostTags and returns the data updated in the database.
   * @param {PostTagUpdateManyAndReturnArgs} args - Arguments to update many PostTags.
   * @example
   * // Update many PostTags
   * const postTag = await prisma.postTag.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more PostTags and only return the `postId`
   * const postTagWithPostIdOnly = await prisma.postTag.updateManyAndReturn({
   *   select: { postId: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends PostTagUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, PostTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one PostTag.
   * @param {PostTagUpsertArgs} args - Arguments to update or create a PostTag.
   * @example
   * // Update or create a PostTag
   * const postTag = await prisma.postTag.upsert({
   *   create: {
   *     // ... data to create a PostTag
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the PostTag we want to update
   *   }
   * })
   */
  upsert<T extends PostTagUpsertArgs>(args: Prisma.SelectSubset<T, PostTagUpsertArgs<ExtArgs>>): Prisma.Prisma__PostTagClient<runtime.Types.Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of PostTags.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PostTagCountArgs} args - Arguments to filter PostTags to count.
   * @example
   * // Count the number of PostTags
   * const count = await prisma.postTag.count({
   *   where: {
   *     // ... the filter for the PostTags we want to count
   *   }
   * })
  **/
  count<T extends PostTagCountArgs>(
    args?: Prisma.Subset<T, PostTagCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], PostTagCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a PostTag.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PostTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends PostTagAggregateArgs>(args: Prisma.Subset<T, PostTagAggregateArgs>): Prisma.PrismaPromise<GetPostTagAggregateType<T>>

  /**
   * Group by PostTag.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PostTagGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends PostTagGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: PostTagGroupByArgs['orderBy'] }
      : { orderBy?: PostTagGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, PostTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the PostTag model
 */
readonly fields: PostTagFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for PostTag.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__PostTagClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  post<T extends Prisma.PostDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PostDefaultArgs<ExtArgs>>): Prisma.Prisma__PostClient<runtime.Types.Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  tag<T extends Prisma.TagDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TagDefaultArgs<ExtArgs>>): Prisma.Prisma__TagClient<runtime.Types.Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the PostTag model
 */
export interface PostTagFieldRefs {
  readonly postId: Prisma.FieldRef<"PostTag", 'String'>
  readonly tagId: Prisma.FieldRef<"PostTag", 'String'>
}
    

// Custom InputTypes
/**
 * PostTag findUnique
 */
export type PostTagFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagInclude<ExtArgs> | null
  /**
   * Filter, which PostTag to fetch.
   */
  where: Prisma.PostTagWhereUniqueInput
}

/**
 * PostTag findUniqueOrThrow
 */
export type PostTagFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagInclude<ExtArgs> | null
  /**
   * Filter, which PostTag to fetch.
   */
  where: Prisma.PostTagWhereUniqueInput
}

/**
 * PostTag findFirst
 */
export type PostTagFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagInclude<ExtArgs> | null
  /**
   * Filter, which PostTag to fetch.
   */
  where?: Prisma.PostTagWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PostTags to fetch.
   */
  orderBy?: Prisma.PostTagOrderByWithRelationInput | Prisma.PostTagOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for PostTags.
   */
  cursor?: Prisma.PostTagWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PostTags from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PostTags.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of PostTags.
   */
  distinct?: Prisma.PostTagScalarFieldEnum | Prisma.PostTagScalarFieldEnum[]
}

/**
 * PostTag findFirstOrThrow
 */
export type PostTagFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagInclude<ExtArgs> | null
  /**
   * Filter, which PostTag to fetch.
   */
  where?: Prisma.PostTagWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PostTags to fetch.
   */
  orderBy?: Prisma.PostTagOrderByWithRelationInput | Prisma.PostTagOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for PostTags.
   */
  cursor?: Prisma.PostTagWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PostTags from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PostTags.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of PostTags.
   */
  distinct?: Prisma.PostTagScalarFieldEnum | Prisma.PostTagScalarFieldEnum[]
}

/**
 * PostTag findMany
 */
export type PostTagFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagInclude<ExtArgs> | null
  /**
   * Filter, which PostTags to fetch.
   */
  where?: Prisma.PostTagWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PostTags to fetch.
   */
  orderBy?: Prisma.PostTagOrderByWithRelationInput | Prisma.PostTagOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing PostTags.
   */
  cursor?: Prisma.PostTagWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PostTags from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PostTags.
   */
  skip?: number
  distinct?: Prisma.PostTagScalarFieldEnum | Prisma.PostTagScalarFieldEnum[]
}

/**
 * PostTag create
 */
export type PostTagCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagInclude<ExtArgs> | null
  /**
   * The data needed to create a PostTag.
   */
  data: Prisma.XOR<Prisma.PostTagCreateInput, Prisma.PostTagUncheckedCreateInput>
}

/**
 * PostTag createMany
 */
export type PostTagCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many PostTags.
   */
  data: Prisma.PostTagCreateManyInput | Prisma.PostTagCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * PostTag createManyAndReturn
 */
export type PostTagCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * The data used to create many PostTags.
   */
  data: Prisma.PostTagCreateManyInput | Prisma.PostTagCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * PostTag update
 */
export type PostTagUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagInclude<ExtArgs> | null
  /**
   * The data needed to update a PostTag.
   */
  data: Prisma.XOR<Prisma.PostTagUpdateInput, Prisma.PostTagUncheckedUpdateInput>
  /**
   * Choose, which PostTag to update.
   */
  where: Prisma.PostTagWhereUniqueInput
}

/**
 * PostTag updateMany
 */
export type PostTagUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update PostTags.
   */
  data: Prisma.XOR<Prisma.PostTagUpdateManyMutationInput, Prisma.PostTagUncheckedUpdateManyInput>
  /**
   * Filter which PostTags to update
   */
  where?: Prisma.PostTagWhereInput
  /**
   * Limit how many PostTags to update.
   */
  limit?: number
}

/**
 * PostTag updateManyAndReturn
 */
export type PostTagUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * The data used to update PostTags.
   */
  data: Prisma.XOR<Prisma.PostTagUpdateManyMutationInput, Prisma.PostTagUncheckedUpdateManyInput>
  /**
   * Filter which PostTags to update
   */
  where?: Prisma.PostTagWhereInput
  /**
   * Limit how many PostTags to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * PostTag upsert
 */
export type PostTagUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagInclude<ExtArgs> | null
  /**
   * The filter to search for the PostTag to update in case it exists.
   */
  where: Prisma.PostTagWhereUniqueInput
  /**
   * In case the PostTag found by the `where` argument doesn't exist, create a new PostTag with this data.
   */
  create: Prisma.XOR<Prisma.PostTagCreateInput, Prisma.PostTagUncheckedCreateInput>
  /**
   * In case the PostTag was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.PostTagUpdateInput, Prisma.PostTagUncheckedUpdateInput>
}

/**
 * PostTag delete
 */
export type PostTagDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagInclude<ExtArgs> | null
  /**
   * Filter which PostTag to delete.
   */
  where: Prisma.PostTagWhereUniqueInput
}

/**
 * PostTag deleteMany
 */
export type PostTagDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which PostTags to delete
   */
  where?: Prisma.PostTagWhereInput
  /**
   * Limit how many PostTags to delete.
   */
  limit?: number
}

/**
 * PostTag without action
 */
export type PostTagDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PostTag
   */
  select?: Prisma.PostTagSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PostTag
   */
  omit?: Prisma.PostTagOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PostTagInclude<ExtArgs> | null
}
